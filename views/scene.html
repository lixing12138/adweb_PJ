<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset=utf-8>
    <title>场景漫游——多人交互</title>
    <link href="style.css" rel="stylesheet" type="text/css" />
</head>


<body>
    <div id="block">
        <div id="chatLog">
            <div class="scrollbar" id="scrollbar-y"></div>
            <div class="scrollbar" id="scrollbar-x"></div>
        </div>
        <div id="chat">
            <select id="userList">
                <option value = "all">all</option>
            </select>
            <input id="chatMany" autofocus=autofocus value="">
        </div>
    </div>
    <div id="description">
        <h3 id="title"></h3>
        <p id="content"></p>
    </div>
    <div id="user">
        <p>姓名：<span id="getUserName">{{ name }}</span></p>
        <p>性别：<span id="gender">{{ gender || '中'}}</span></p>
        <p>称号：
            <span id="getLevel">
                {{if (score > 300)}}盖世才子{{else if (score>150) }}名震一方{{else if (score>100) }}小有成就{{ else if(score>60)}}略知一二{{ else if(score>30)}}初入学途{{ else if(score>15)}}稚嫩学童{{ else}}暂无称号{{/if}}
            </span>
        </p>
        <p>积分：<span id="score">{{ score || '0' }}</span></p>
    </div>
    <div id="questions">

        <div id="close"></div>
        <div id="question" data-id="" data-count=0>
            <div id="question-title">题目 0/15 </div>
            <div id="detail"></div>
            <div id="options">
                <label for="optionT">答案</label>
                <input name="option" type="radio" id="optionT" checked="checked" />T
                <label for="optionF"></label>
                <input name="option" type="radio" id="optionF" />F
            </div>
            <button id="viewAnswer">提交答案</button>
            <button id="viewNext">下一题</button>
        </div>
        <div id="answer"></div>
    </div>
    <script src="/libs/three.min.js"></script>
    <script src="/libs/socket.io.js"></script>
    <script src="/libs/Reflector.js"></script>
    <script src="/libs/GLTFLoader.js"></script>
    <script>
        // const socket = io('3.87.214.11:3003');
        const socket = io('localhost:3003');
    </script>
    <script src="/libs/FirstPersonControl.js"></script>
    <script src="/libs/RectAreaLightUniformsLib.js"></script>
    <script src="/libs/Tool.js"></script>
    <script src="/libs/OrbitControls.js"></script>
    <script src="/libs/Showcase.js"></script>
    <script src="/libs/content.js"></script>

    <script src="https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js"></script>
    <script src="/libs/question.js"></script>
    <script src="/libs/Museum.js"></script>
    <script>
        let museum;
        let renderer;
        let showcase;
        let hatType = 0;
        let playerMap = new Map(); //玩家id与模型对应
        let hatMap = new Map(); //玩家id与帽子对应
        let sceneMap = new Map(); //玩家id与场景对应
        let nameMap = new Map(); //玩家id与昵称对应
        let noRepeat = true; //禁止持续更换场景
        const SCREEN_WIDTH = window.innerWidth,
            SCREEN_HEIGHT = window.innerHeight;
        socket.emit('login', {
            name: $("#getUserName").text()
        });

        function init() {
            showing = false;
            museum = new Museum();
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
            document.body.appendChild(renderer.domElement);
            showcase = new Showcase(renderer);
            museum.initMuseum();
            render();
            scenesGroup[1] = new THREE.Object3D();
            museum.initSecond();
        }

        let clock = new THREE.Clock();

        function render() {
            let delta = clock.getDelta();
            museum.fpc.update(delta);
            museum.arrowHelper.position.y += museum.arrowFloat;
            if (museum.arrowHelper.position.y > 11)
                museum.arrowFloat = -0.05;
            if (museum.arrowHelper.position.y < 9)
                museum.arrowFloat = 0.05;
            museum.arrowHelper.visible = noRepeat;
            if (showing)
                renderer.render(showcase.scene, showcase.camera);
            else
                renderer.render(museum.scene, museum.camera);
            socket.emit('player', {
                position: museum.fpc.yawObject.position,
                rotation: museum.fpc.yawObject.rotation,
                index: museum.index,
                gender: document.getElementById("gender").innerText
            });
            for (let i = 0; i < mixers.length; i++) { // 重复播放动画
                mixers[i].update(delta / playSpeed);
            }
            requestAnimationFrame(render);
        }

        function changeRole(oldIndex, newIndex) {
            for (let id of playerMap) {
                if (sceneMap.get(id[0]) === oldIndex) {
                    museum.scene.remove(playerMap.get(id[0]));
                }
                if (sceneMap.get(id) === newIndex)
                    museum.scene.add(playerMap.get(id[0]));
            }
        }

        function getHat(type) {
            switch (type) {
                case 1:
                    loader.load("/resources/hat/1/scene.gltf", function(mesh) {
                        mesh.scene.scale.set(0.6, 0.6, 0.6);
                        mesh.scene.position.set(0, 58, 200);
                        return mesh.scene;
                    });
                    break;
                case 2:
                    loader.load("/resources/hat/2/scene.gltf", function(mesh) {
                        mesh.scene.scale.set(4, 4, 4);
                        mesh.scene.position.set(0, 57, 300);
                        return mesh.scene;
                    });
                    break;
                case 3:
                    loader.load("/resources/hat/3/scene.gltf", function(mesh) {
                        mesh.scene.scale.set(320, 320, 320);
                        mesh.scene.position.set(0, 27, 400);
                        return mesh.scene;
                    });
                    break;
                case 4:
                    loader.load("/resources/hat/4/scene.gltf", function(mesh) {
                        mesh.scene.scale.set(4, 4, 4);
                        mesh.scene.position.set(0, 63, 500);
                        return mesh.scene;
                    });
                    break;
            }
            return null;
        }

        //用户数据和响应
        socket.on('player', data => {
            if (playerMap.has(data.socketid)) {
                let model = playerMap.get(data.socketid);
                if (model === null) {
                    return;
                }
                model.position.set(data.position.x, data.position.y + 30, data.position.z);
                model.rotation.set(data.rotation._x, data.rotation._y + Math.PI, data.rotation._z);
                let hat = hatMap.get(data.socketid);
                if (hat !== null) {
                    hat.position.set(data.position.x, data.position.y, data.position.z);
                    hat.rotation.set(data.rotation._x, data.rotation._y, data.rotation._z);
                }
                if (data.index !== sceneMap.get(data.socketid)) {
                    if (sceneMap.get(data.socketid) === museum.index) {
                        museum.scene.remove(playerMap.get(data.socketid));
                        museum.scene.remove(hatMap.get(data.socketid));
                    }
                    sceneMap.set(data.socketid, data.index);
                    if (data.index === museum.index) {
                        museum.scene.add(playerMap.get(data.socketid));
                        museum.scene.add(hatMap.get(data.socketid));
                    }
                }
            } else {
                playerMap.set(data.socketid, null);
                hatMap.set(data.socketid, null);
                if (data.gender === "男") {
                    loader.load("/resources/role/man/scene.gltf", (mesh) => {
                        mesh.scene.scale.set(30, 30, 30);
                        mesh.scene.name = "person";
                        playerMap.set(data.socketid, mesh.scene);
                        sceneMap.set(data.socketid, data.index);
                        if (data.index === museum.index) {
                            museum.scene.add(playerMap.get(data.socketid));
                        }
                    });
                } else {
                    loader.load("/resources/role/woman/scene.gltf", (mesh) => {
                        mesh.scene.scale.set(12, 12, 12);
                        mesh.scene.position.set(0, 8, 0);
                        mesh.scene.name = "person";
                        playerMap.set(data.socketid, mesh.scene);
                        sceneMap.set(data.socketid, data.index);
                        if (data.index === museum.index) {
                            museum.scene.add(playerMap.get(data.socketid));
                        }
                    });
                }
            }
        });

        socket.on('offline', data => {
            if (sceneMap.get(data.socketid) === museum.index)
                museum.scene.remove(playerMap.get(data.socketid));
            playerMap.delete(data.socketid);
            sceneMap.delete(data.socketid);
            nameMap.delete(data.socketid);
            let userList = document.getElementById("userList");
            let option = document.getElementById(data.socketid);
            userList.removeChild(option);
        });
        //xwl 多人聊天
        socket.on('chatMany', data => {
            let chatP = document.createElement("p");
            chatP.style.maxWidth = "250px";
            chatP.innerHTML = data.name + ":" + (data.message || "");
            chatLog.appendChild(chatP);
            if (chatLog.children.length > 2) {
                chatLog.lastChild.scrollIntoView();
            }
        });
        socket.on('chatOne', data => {
            let chatP = document.createElement("p");
            chatP.style.maxWidth = "250px";
            chatP.innerHTML = data.from + " ：" + (data.message || "");
            chatLog.appendChild(chatP);
            if (chatLog.children.length > 2) {
                chatLog.lastChild.scrollIntoView();
            }
        });
        socket.on('login', data => {
            console.log(111);
            console.log(data);
            data.userMap.forEach(t => {
                $("#userList").empty();
                $("#userList").append("<option value = '" + t.socketid + "'>" + t.name + "</option>");
            });
        });
        socket.on('hat', data => {
            let type = data.type;
            if (hatMap.get(data.socketid) !== null) {
                if (sceneMap.get(data.socketid) === museum.index)
                    museum.scene.remove(hatMap.get(data.socketid));
                deleteGroup(hatMap.get(data.socketid));
            }
            alert(1111);
            hatMap.set(data.socketid, getHat(type));
            if (sceneMap.get(data.socketid) === museum.index)
                museum.scene.add(hatMap.get(data.socketid));
        });
        window.addEventListener("resize", function() {
            museum.camera.aspect = window.innerWidth / window.innerHeight;
            museum.camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        const KEY_B = 66;
        const KEY_C = 67;
        const KEY_N = 78;
        const KEY_O = 79;
        const KEY_Q = 81;
        document.addEventListener("keydown", function(e) {
            if (museum.fpc.canChat)
                return;
            let distance = Math.sqrt(Math.pow(museum.fpc.yawObject.position.x, 2) + Math.pow(museum.fpc.yawObject.position.z, 2));
            if (distance > 25) {
                noRepeat = true;
            }
            switch (e.keyCode) {
                case KEY_B:
                    if (distance < 25 && noRepeat) {
                        console.log('enter');
                        noRepeat = false;

                        if (museum.index !== 0) {
                            changeRole(this.index, this.index - 1);
                            museum.back();
                        }
                    }
                    break;
                case KEY_C:
                    if (hatType >= 0 && hatType < 4) {
                        alert(2222);
                        hatType++;
                        socket.emit('hat', {
                            type: hatType
                        });
                    } else if (type === 4) {
                        hatType = 0;
                        socket.emit('hat', {
                            type: hatType
                        });
                    }
                    break;
                case KEY_N:
                    if (distance < 25 && noRepeat) {
                        noRepeat = false;
                        if (museum.index !== 4) {
                            changeRole(this.index, this.index + 1);
                            museum.forward();
                        }
                    }
                    break;
                case KEY_O:
                    if (museum.index === 0)
                        return;
                    showing = !showing;
                    if (showing) {
                        museum.scene.remove(scenesGroup[museum.index]);
                        showcase.show(museum.getShowModel(), museum.index - 1);
                        museum.fpc.removeLock();
                        document.exitPointerLock();
                    } else {
                        let model = showcase.delete();
                        scenesGroup[museum.index].add(model);
                        museum.scene.add(scenesGroup[museum.index]);
                        museum.fpc.addLock();
                        museum.fpc.domElement.requestPointerLock();
                    }
                    break;
                case KEY_Q:
                    if (museum.index !== 2)
                        return;
                    let openQuestion = Math.sqrt(Math.pow(museum.fpc.yawObject.position.x + 350, 2) + Math.pow(museum.fpc.yawObject.position.z - 150, 2));
                    openQuestion = openQuestion < 50;
                    if (openQuestion) {
                        museum.fpc.removeLock();
                        document.exitPointerLock();
                        getQuestion();
                    }
                    break;
            }
        });
        init();
    </script>
</body>

</html>